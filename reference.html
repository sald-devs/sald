<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Sald Reference</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
    <div id="header">
      <nav>
        <li class="fork"><a href="https://github.com/sald-devs/sald">View On GitHub</a></li>
        <li class="downloads"><a href="https://github.com/sald-devs/sald/zipball/master">ZIP</a></li>
        <li class="downloads"><a href="https://github.com/sald-devs/sald/tarball/master">TAR</a></li>
        <li class="title">DOWNLOADS</li>
      </nav>
    </div><!-- end header -->

    <div class="wrapper">

    <section>
      <div id="title">
        <h1>S.A.L.D.</h1>
        <p>Studio A Ludum Dare JS Game Engine</p>
        <hr>
        <p><a href="http://sald-devs.github.io/sald/">Home</a> | <a href="http://sald-devs.github.io/sald/reference.html">Reference</a> | <a href="http://sald-devs.github.io/sald/examples.html">Examples</a> | <a href="http://sald-devs.github.io/sald/about.html">About Us</a> </p>
        <hr>
        <span class="credits left">Project maintained by <a href="https://github.com/sald-devs">sald-devs</a></span>
        <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
      </div>

      <h1>
      <a name="top"></a>
      <a id="reference" class="anchor" href="#reference" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h1>
      <p>
          Here is the full reference docs for SALD. Still undergoing development.
      </p>

      <ul>
        <h4><a href="#benchmark">Benchmark.js</a> - Utility functions for benchmarking</h4>
        <h4><a href="#collide">Collide.js</a> - Collision checking functions</h4>
        <h4><a href="#gameobject">GameObject.js</a> - Basic game object with common properties and functions</h4>
        <h4><a href="#mainloop">Mainloop.js</a> - Basic mainloop</h4>
        <h4><a href="#sound">Sound.js</a> - Basic sound functionalities</h4>        
        <h4><a href="#sprite">Sprite.js</a> - Spritesheets and easy frame selections and animations</h4>
        <h4><a href="#tilemap">Tilemap.js</a> - 2D tile system</h4>
      </ul>
      
      <hr>
      <a name="benchmark"></a>
      <div class="jump" id="benchmarkRef">
        <h2>Benchmark</h2>
          <p>The benchmark library can be used to calculate some data about the performance of a function.</p>

          <h3>Example</h3>
<pre><code>var benchmark = require('sald:benchmark');

function myReallySlowFunction() {
  var i = 0;
  for(var j = 0; j &lt; 1000000000; j++) {
    i++;
  }
}

console.log(benchmark(myReallySlowFunction, {iterations: 1000, timeout: 10}));</code></pre>
          <h3>Functions</h3>
          <h4>benchmark(fn,opts)</h4>

          <p>benchmark will run fn a number of times specified by opts, either in iterations or elapsed time,
          and return stats about the runtime performance of that fn.</p>

          <h5>Parameters</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>fn</td>
              <td>function</td>
              <td>the function to benchmark</td>
            </tr>
            <tr>
              <td>opts</td>
              <td>object</td>
              <td>the options object which specifies iterations, timeout(ms), or both</td>
            </tr>
          </table>
          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>avg</td>
              <td>float</td>
              <td>average runtime for each call to fn (ms)</td>
            <tr>
            <tr>
              <td>min</td>
              <td>float</td>
              <td>minimum runtime for each call to fn (ms)</td>
            </tr>
            <tr>
              <td>total</td>
              <td>float</td>
              <td>total time it takes to run every iteration of fn (ms)</td>
            </tr>
            <tr>
              <td>iters</td>
              <td>int</td>
              <td>total number of times fn executed</td>
            </tr>
          </table> 
      </div>


<!-- ***************************** -->
<!-- ****   Collide Section   **** -->
<!-- ***************************** -->

      <hr>
      <a name="collide"></a>
      <div class="jump" id="collideRef">  
        <h2>Collide</h2>
          <p>The collision library is used to test collisions between various shapes. The compiled collide.js can be viewed [here](../sald/collide.js)</p>
          <p>The collide.js currently supports 6 collision detection functions as follows:</p>
          <ul>
            <li>Circle vs Circle</li>
            <li>Rectangle vs Rectangle</li>
            <li>Polygon vs Polygon {Convex}</li>
            <li>Ray vs Circle</li>
            <li>Ray vs Rectangle</li>
            <li>Ray vs Convex Polygon</li>
          </ul>

          <h3>Shape Definitions</h3>

          <h4>Circle</h4>
          <p>A circle defined by the center and radius.</p>
<pre><code>{
  x: the x coordinate of the center of the circle
  y: the y coordinate of the center of the circle
  r: the radius of the circle
}</code></pre>

          <h4>Rectangle</h4>
          <p>A rectangle defined by the top left and bottom right points.</p>
<pre><code>{
  min : {
    x: the minimum x coordinate of the rectangle
    y: the minimum y coordinate of the rectangle
  },
  max: {
    x: the maximum x coordinate of the rectangle
    y: the maximum y coordinate of the rectangle
  }
}</code></pre>

          <h4>Polygon</h4>
          <p>A polygon defined by the verticies.</p>
<pre><code>[
  {
    x: the x coordinate of a vertex in the polygon
    y: the y coordinate of a vertex in the polygon
  },
  ...
]</code></pre>

          <h4>Ray</h4>
          <p>Ray defined by the start and end points.</p>
<pre><code>{
  start: {
    x: x coordinate of the start of the ray
    y: y coordinate of the start of the ray
  },
  end: {
    x: x coordinate of the end of the ray
    y: y coordinate of the end of the ray
  }
}</code></pre>

          <h3>Functions</h3>

          <h4>function rectangleRectangle(r1,r2)</h4>
          <p>Check to see if r1 and r2 overlap</p>

          <h5>Parameters</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>r1</td>
              <td>Rectangle</td>
              <td>First rectangle to check</td>
            </tr>
            <tr>
              <td>r2</td>
              <td>Rectangle</td>
              <td>Second rectangle to check</td>
            </tr>
          </table>

          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>var</td>
              <td>bool</td>
              <td>true if r1 and r2 overlap, otherwise false</td>
            </tr>
          </table>

          <h4>function rayRectangle(r,b)</h4>
          <p>Check to see if r intersetcts b, and return where if it does</p>

          <h3>Parameters</h3>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>r</td>
              <td>Ray</td>
              <td>Ray to check for intersection</td>
            </tr>
            <tr>
              <td>b</td>
              <td>Rectangle</td>
              <td>Rectangle being intersected</td>
            </tr>
          </table>

          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>var</td>
              <td>object</td>
              <td>{t: t} if there is an intersection at (r.start + (r.end - r.start)*t), otherwise null</td>
            </tr>
          </table>

          <h4>function circleCircle(c1,c2)</h4>
          <p>Check to see if c1 and c2 overlap</p>

          <h3>Parameters</h3>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>c1</td>
              <td>Circle</td>
              <td>First circle to check</td>
            </tr>
            <tr>
              <td>c2</td>
              <td>Circle</td>
              <td>Second circle to check</td>
            </tr>
          </table>

          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>var</td>
              <td>bool</td>
              <td>true if c1 and c2 overlap, otherwise false</td>
            </tr>
          </table>

          <h4>function rayCircle(r,c)</h4>
          <p>Check to see if r intersetcts c, and return where if it does</p>

          <h5>Parameters</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>r</td>
              <td>Ray</td>
              <td>Ray to check for intersection</td>
            </tr>
            <tr>
              <td>c</td>
              <td>Circle</td>
              <td>Circle to being intersected</td>
            </tr>
          </table>

          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>var</td>
              <td>object</td>
              <td>{t: t} if there is an intersection at (r.start + (r.end - r.start)*t), otherwise null</td>
            </tr>
          </table>

          <h4>function convexConvex(p1, p2)</h4>
          <p>Check to see if p1 and p2 (Convex Polygons) overlap</p>

          <h5>Parameters</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>p1</td>
              <td>Polygon</td>
              <td>First polygon to check</td>
            </tr>
            <tr>
              <td>p2</td>
              <td>Polygon</td>
              <td>Second polygon to check</td>
            </tr>
          </table>

          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>var</td>
              <td>bool</td>
              <td>true if p1 and p2 overlap, otherwise false</td>
            </tr>
          </table>

          <h4>function rayConvex(r,p)</h4>
          <p>Check to see if r intersetcts p (Convex Polygon), and return where if it does</p>

          <h5>Parameters</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>r</td>
              <td>Ray</td>
              <td>Ray to check for intersection</td>
            </tr>
            <tr>
              <td>p</td>
              <td>Polygon</td>
              <td>Polygon being intersected</td>
            </tr>
          </table>

          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>var</td>
              <td>object</td>
              <td>{t: t} if there is an intersection at (r.start + (r.end - r.start)*t), otherwise null</td>
            </tr>
          </table>
          <h4><a href="#top">Return to top</a></h4>
      </div>


<!-- ***************************** -->
<!-- **** Game Object Section **** -->
<!-- ***************************** -->

      <hr>
      <a name="gameobject"></a>
      <div class="jump" id="gameobjectRef">  
        <h2>Game Object</h2>
        <p>GameObjects can be used to define characters and objects in the game world which can collide. GameObject.js can be viewed [here](../sald/GameObject.js)</p>
        
        <h3>Usage</h3>
        <p>Require GameObject.js in your code</p>
<pre><code>var GameObject = require('sald:GameObject.js');</code></pre>

        <p>Following which you, you can create new instances of GameObject.</p>
        <p>Note, by default a game object has a rectangular collider from its top left corner (x, y) to the bottom right corner (x + width, y + height).</p>

        <p>If you want to override this default behavior, pass 0 for width or 0 for height on initialization.*</p>

        <h4>Example</h4>
<pre><code>var x = 0;
var y = 0;
var width = 20;
var height = 60;
var anchor = { x : 0, y : 0 }; // this is the top left corner, which happens by default {x : 1, y : 1} is the bottom right corner

var player = new GameObject(x, y, width, height);

// is the same as

var player2 = new GameObject(x, y, width, height, { x : 0, y : 0 });</code></pre>

        <h3>Custom Collision Shapes</h3>
        <p>If you want the collision shape to be different, you can change it. For example:</p>
<pre><code>...

var player1 = new GameObject(x, y, width, height, anchor);

...

// A circle with radius 20, 120 pixels in on the x axis, 40 pixels in on the y axis from the anchor
// r : radius, x : x position of center, y : y position of center
var circle = {
  r : 20,
  x : 120,
  y : 40,
};

// A circle half the width away from the anchor and half the height away from the anchor
var relativeCircle = {
  r : 0.5, // r is relative to the GameObject's width
  x : 0.5,
  y : 0.5
}

// min : top left corner, max : bottom right corner
var rectangle = {
  min : {
    x : 20,
    y : 20
  },
  max : {
    x : 80,
    y : 60
  }
};

var relativeRectangle = {
  min : {
    x : -0.5,
    y : -0.5
  },
  max : {
    x : 0.5,
    y : 0.5
  }
}

// a list of {x, y} points listed in Counter Clockwise order which form a convex polygon.
var convexPolygon = [
  {x : 20, y : 20},
  {x : 10, y : 30},
  {x : 20, y : 40},
  {x : 30, y : 30}
];

player1.setCollisionRect(rectangle, false);

player2.setCollisionRect(relativeRectangle, true);

player3.setCollisionCircle(circle, false);

player4.setCollisionCircle(relativeCircle, true);

player5.setCollisionConvex(convexPolygon, false);</code></pre>

        <h3>Specifications</h3>

        <p>GameObject.js supports collisions between Convex Polygons, Circles, and Rectangles. Any two of the listed shapes can collide with each other. (circle/circle, rectangle/circle, etc.)</p>

<pre><code>if (player.isColliding(ball)){
  // decide what happens when the objects are colliding
}</code></pre>

        <p>You can also retrieve the collision shape as follows:</p>

        <pre><code>var shape = player.collisionShape();</code></pre>

        <p>Shape will be null if there is no collider, otherwise it will be a json object containing a key that is either "rect", "circle", or "convex", and the value will be the collision object.</p>

        <p>The returned object will not be relative to the objects width and height, but rather absolute, in order to compute collisions with the collision library should you want to add extra functionality (see ray collisions).</p>
        <h4><a href="#top">Return to top</a></h4>
      </div>


<!-- ***************************** -->
<!-- ****** Mainloop Section ***** -->
<!-- ***************************** -->

      <hr>
      <a name="mainloop"></a>
      <div class="jump" id="mainloopRef">  
        <h2>Mainloop</h2>
        <p>SALD provides a basic mainloop. To use, attach to a canvas with:</p>
<pre><code>mainloop.start( ):
var mainloop = require('sald:mainloop.js');

//configure size and callbacks:
sald.size = {x:320, y:240, mode:"exact"};
sald.scene = myScene;

//call this once the page has loaded:
mainloop.start(document.getElementById("canvas"));</code></pre>

        <p>
          The <code>mainloop.start()</code> method takes a second options argument, which currently only has one supported option -- <code>gl</code> -- which creates a webgl context instead of a 2d context, and uses the supplied attributes:
        </p>
        <ul>
          mainloop.start(document.getElementById("canvas"), {gl:{}}); //webgl canvas, default attribs
          mainloop.start(document.getElementById("canvas"), {gl:{antialias:false}}); //webgl canvas, 'antialias' attribs set false
        </ul>

        <p>A list of possible attributes are available at https://www.khronos.org/registry/webgl/specs/1.0/#5.2 .</p>

        <p>The mainloop module uses the following properties in the `sald` namespace:</p>

        <h3>Canvas</h3>

        <p>sald.size configures the desired canvas size and resizing behavior:</p>

        <p>If mode is not specified, or is "exact"` size is set exactly in pixels:</p>
<pre><code>sald.size = {x:320, y:240}; 
sald.size = {x:320, y:240, mode:"exact"};</code></pre>

        <p>If <code>mode</code> is <code>multiple</code>, canvas size will be an integer multiple of the given size.
      This is good for pixel-art games, or games that want an exact aspect ratio:</p>
        <ul>
          sald.size = {x:320, y:240, mode:"multiple"}; //pixel art game with 320x240 canvas
          sald.size = {x:16, y:9, mode:"multiple"}; //game wants to be exactly 16x9 aspect
        </ul>

        <p>If <code>mode</code> is <code>ratio</code>, canvas size will be an rounded, non-integer multiple of the size.
        This is good for games that just want an approximate aspect ratio:</p>
        <ul>
          sald.size = {x:1, y:1, mode:"ratio"}; //square canvas
          sald.size = {x:16, y:9, mode:"ratio"}; //16x9-ish, might not be exact due to rounding
        </ul>
        <hr>

        <p>`sald.ctx` is the drawing context associated with the canvas. SALD adds some extra properties:</p>
        <ul>
          sald.ctx.width //current width
          sald.ctx.height //current height
          sald.ctx.factor //scaling factor relative to sald.size
        </ul>

        <p>One generally uses `ctx.factor` to set the `ctx`'s transform to allow working in "virtual pixels":</p>

<pre><code>sald.size = {x:320, y:240, mode:"multiple"}; //canvas will be some multiple of 320x240
function draw() {
  var ctx = sald.ctx;

  //scale to account for pixel size:
  ctx.setTransform(ctx.factor,0, 0,ctx.factor, 0,0);

  //draw full-screen pink rectangle:
  ctx.fillStyle = "#f0f"; //bright pink
  ctx.fillRect(0, 0, 320, 240); //&lt;-- working in pixel units

}</code></pre>

        <h3>Input</h3>

        <p>`sald.keys` contains the names of every held-down key. (Key names are specified in mainloop.js)</p>

<pre><code>function update(elapsed) {
  var keys = sald.keys;
  if (keys.LEFT) player.x -= 10.0 * elapsed;
  if (keys.RIGHT) player.x += 10.0 * elapsed;
}</code></pre>

        <hr>

        <p>sald.mouse contains the position (in pixels from the upper-left corner of the canvas) and held-down buttons for the mouse. NOTE: `mouse === null` if no mouse events have happened yet.</p>

<pre><code>function update(elapsed) {
  var mouse = sald.mouse;
  if (mouse && mouse.buttons.LEFT) {
    console.log("Left button held down; currently at " + mouse.x + ", " + mouse.y + ".");
  }
}</code></pre>

        <h3>Callbacks</h3>

        <p>The `sald.scene` object holds callbacks used by the mainloop to define custom update, draw, and event handlers. You can package handlers together and assign to scene all at once, or assign each function individually.</p>

        <p>The `sald.scene.update` function is called with the current elapsed time. You can use it to update game state.</p>

        <p>The `sald.scene.draw` function is called once per frame. It should draw the current game state into `sald.ctx`.</p>

        <p>Considering the Model-View-Controller paradigm, the update function should update the model, while the draw function should update the view.</p>

<pre><code>function update(elapsed){
  // elapsed is a float measure of how many seconds have passed since the last update
}

sald.scene.update = update;

function draw(){
  // draw whatever should be on the screen, using sald.ctx
}

sald.scene.draw = draw;</code></pre>

        <hr>

        <p>The `sald.scene.key` function is called every time a key is pressed or released:</p>

<pre><code>function key(keyName, isPressed){
  if (keyName === "SPACE" && isPressed) {
    console.log("You pressed space.");
  }
}

window.sald.scene.key = key;</code></pre>

        <p>NOTE: On a Mac, `sald.keys.WINDOWS` is the "Command" key.</p>

        <hr>

        <p>The `sald.scene.mouse` function is called whenever a mouse button is pressed or the mouse moves:</p>

<pre><code>function mouse(position, buttonName, isPressed) {
  if (buttonName === undefined) {
    //just movement
  } else {
    if (buttonName === "MIDDLE") {
      console.log("Middle button " + (isPressed ? "down" : "up") + ".");
    }
  }
}
sald.scene.mouse = mouse;</code></pre>

        <p>NOTE: when the mouse is moved, this function will be called with `buttonName` and `isPressed` undefined.</p>

NOTE 2: `sald.takeRightClickInput` (default: true) can be set to false to allow right click events to open the context menu as expected.

        <hr>

        <p>The `sald.scene.wheel` function handles scroll wheel events:</p>
<pre><code>function wheel(delta) {
}
sald.scene.wheel = wheel;</code></pre>

        <p>NOTE: if not defined, scroll events will scroll the page as usual.</p>
        <h4><a href="#top">Return to top</a></h4>
      </div>


<!-- ***************************** -->
<!-- ******* Sound Section ******* -->
<!-- ***************************** -->

      <hr>
      <a name="sound"></a>
      <div class="jump" id="soundRef">  
        <h2>Sound</h2>
        <p>SALD provides a sound support. To use first require sound.js in your code</p>
        <pre><code>var soundController = require('sald:sound.js');</code></pre>

        <p>Require individual sound files, then play</p>
<pre><code>var explosionSound = require('./data/sounds/explosion.ogg');
explosionSound.play();</code></pre>

        <p>Currently, the sound module only supports .ogg files. Here is an online file converter:
        <a href="http://audio.online-convert.com/convert-to-ogg">http://audio.online-convert.com/convert-to-ogg</a></p>

        <h3>Sound Controller</h3>
        <p>Use sound controller to control the master volume.</p>

<pre><code>soundController.setVolume(float from 0.0 to 1.0);
soundController.getVolume() // returns float from 0.0 to 1.0
soundController.toggleMute();
soundController.setIsMuted(boolean);
soundController.isMuted(); // returns boolean</code></pre>

        <h3>CustomAudio Class</h3>
        <p>The CustomAudio class is used as a wrapper to the Audio html tag. It allows you to play multiple instances of a single sound at the same time.</p>

<pre><code>var explosionSound = require('./data/sound/explosion.ogg');

// The default number of instances is 4
explosionSound.setNumInstances(number of instances);

explosionSound.getVolume(); // returns float between 0.0 and 1.0
explosionSound.setVolume(float between 0.0 and 1.0);
explosionSound.play();
explosionSound.setShouldLoop(boolean);
explosionSound.doesLoop(); // returns boolean
explosionSound.getNumberOfLiveInstances() // How many of this sound is playing right now
explosionSound.pause(); // pauses all instances of this sound, allowing you to resume at any point
explosionSound.resume(); // resumes paused audio
explosionSound.stop(); // Stops all instances of this sounds audio, with no ability to resume</code></pre>
        <h4><a href="#top">Return to top</a></h4>
      </div>



<!-- ***************************** -->
<!-- ******* Sprite Section ****** -->
<!-- ***************************** -->

      <hr>
      <a name="sprite"></a>
      <div class="jump" id="spriteRef">  
        <h2>Sprite</h2>
        <p>Allows the user to draw sprites from a spritesheet and define various animations to be drawn</p>

        <h3>Usage</h3>
        <p>Create a new sprite object in your game scene file like below</p>

<pre><code>var sprite = require('sald:Sprite.js');
var heroImg = require('../img/spritesheet.png');</code></pre>

        <p>All the spritesheet objects to be animated have to be strictly defined as below: </p>

<pre><code>var heroSprite = new sprite(heroImg, {
  'walk' : {
    x:0,y:0,
    width:40,height:60,
    size:4
  },
  'run' : {
    x:0,y:60,
    width:40,height:60,
    size:4
  }
})</code></pre>

        <p>The first parameter is the spritesheet image, heroImg in this case is the entire spritesheet image with several different animation frames within it. The second parameter has to be a list of animations by name along with x, y, width, height and size properties.</p>

        <p>[x,y represent the indexes in pixel coordinates of start row and column of animation from the spritesheet image]
        [width,height represent the width and height of each sprite in pixel size, you can check the same in paint for image width and height in pixels]
        [size is the max number of frames till which that animation needs to be played from the spritesheet image]</p>

        <p>A note about proper sprite splicing: The x and y properties above are what the engine will ultimately use to splice the individual sprites from the sprite sheet. x is the horizontal offset, while y is the vertical offset (with 0,0 representing the top-left corner of the image). There are two things to keep in mind when dealing with pixel coordinates. One - if you truly wish to have well defined and proportional sprites, it helps if the pixel width is divisible by the number of columns and the pixel height is divisible by the number of rows. Otherwise you risk them being clipped at weird positions. Two - If you wish to start cutting from the middle of a sprite sheet and not from the far left, you'll need to make sure that you're providing the top-left corner of the sprite you wish to start at (not the center of the sprite).</p>
        <ul>
        -> The draw function takes the following arguments: 
        * anim: animation name
        * x: x position in world space
        * y: y position in world space
        * scalex: x scale of sprite
        * scaley: y scale of sprite
        * anchorx: x anchor value (0-1)
        * anchory: y anchor value (0-1)
        </ul>

        <p>Call the draw function inside the update loop.</p>
        <pre><code>sprite.draw(anim, x, y, )</code></pre>

        <p>You do not need to give the frame number in draw function anymore because it is handled by a framework called Animators inside the Sprite object. When you initialize a Sprite object, each animation of sprite gets an animator object attached to it internally which handles the state of the animation. It also provides neat features like animation speed, looping functionality and stop feature.</p>

        <p>After creating your sprite, you can call these functions to access animators and its functions:</p>
        <pre><code>
        sprite.animators[&lt;animation-name&gt;].loop(boolean);
          - The boolean here can be true or false depending upon whether you want to loop the animation or not 

        sprite.animators[&lt;animation-name&gt;].speed(speed);
          - The 'speed' has to be in frames/second.
          - It is optional. Default is 60 frames/second.

        sprite.animators[&lt;animation-name&gt;].stop();
          - This function is used to stop the animation from running. And resets that animation's the state. (Can be changed, just a design decision)
        </code></pre>
        <h4><a href="#top">Return to top</a></h4>
      </div>



<!-- ***************************** -->
<!-- ****** Tilemap Section ****** -->
<!-- ***************************** -->

      <hr>
      <div class="jump" id="tilemapRef">  
        <a name="tilemap"></a>
        <h2>Tilemap</h2>
        <p>Require Tilemap.js in your code</p>
        <pre><code>var Tilemap = require('sald:Tilemap.js');</code></pre>

        <p>Initilize Tilemap with correct parameters.</p>
<pre><code>Tilemap(img, map, tilW, tilH, tilR, tilC, defaultTile)
  img  = tilemap image
  map  = 2d map of which location to draw which tile
  tilW = pixel width of individual tile
  tilH = pixel height of individual tile 
  tilR = Height of tilemap in terms of tiles
  tilC = Width of tilemap in terms of tiles
  defaultTile = Number of tile to be draw when outside of map
</code></pre>

        <p>Tilemap.draw(camera) takes in a object that has properties x &amp; y which defines the center of the map to draw from. Call it after updates to tilemap or camera for redraw.</p>
<pre><code>camera = {x : 0, y : 0}
  x = x index location in the 2d world map that was pased to Tilemap
  y = y index location in the 2d world map that was pased to Tilemap
</code></pre>

        <h4><a href="#top">Return to top</a></h4>
      </div>
    </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->  
  </body>
</html>
