<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Sald Reference</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
    <div id="header">
      <nav>
        <li class="fork"><a href="https://github.com/sald-devs/sald">View On GitHub</a></li>
        <li class="downloads"><a href="https://github.com/sald-devs/sald/zipball/master">ZIP</a></li>
        <li class="downloads"><a href="https://github.com/sald-devs/sald/tarball/master">TAR</a></li>
        <li class="title">DOWNLOADS</li>
      </nav>
    </div><!-- end header -->

    <div class="wrapper">

    <section>
      <div id="title">
        <h1>S.A.L.D.</h1>
        <p>Studio A Ludum Dare JS Game Engine</p>
        <hr>
        <p><a href="http://sald-devs.github.io/sald/">Home</a> | <a href="http://sald-devs.github.io/sald/reference.html">Reference</a> | <a href="http://sald-devs.github.io/sald/examples.html">Examples</a> | <a href="http://sald-devs.github.io/sald/about.html">About Us</a> </p>
        <hr>
        <span class="credits left">Project maintained by <a href="https://github.com/sald-devs">sald-devs</a></span>
        <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
      </div>

      <h1>
      <a name="top"></a>
      <a id="reference" class="anchor" href="#reference" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h1>
      <p>
          Here is the full reference docs for SALD. Still undergoing development.
      </p>

      <ul>
        <h4><a href="#benchmark">Benchmark.js</a> - Utility functions for benchmarking</h4>
        <h4><a href="#collide">Collide.js</a> - Collision checking functions</h4>
        <h4><a href="#gameobject">GameObject.js</a> - Basic game object with common properties and functions</h4>
        <h4><a href="#mainloop">Mainloop.js</a> - Basic mainloop</h4>
        <h4><a href="#sound">Sound.js</a> - Basic sound functionalities</h4>        
        <h4><a href="#sprite">Sprite.js</a> - Spritesheets and easy frame selections and animations</h4>
        <h4><a href="#tilemap">Tilemap.js</a> - 2D tile system</h4>
      </ul>
      
      <hr>
      <a name="benchmark"></a>
      <div class="jump" id="benchmarkRef">
        <h2>Benchmark</h2>
          <p>The benchmark library can be used to calculate some data about the performance of a function.</p>

          <h3>Example</h3>
<pre><code>var benchmark = require('sald:benchmark');

function myReallySlowFunction() {
  var i = 0;
  for(var j = 0; j &lt; 1000000000; j++) {
    i++;
  }
}

console.log(benchmark(myReallySlowFunction, {iterations: 1000, timeout: 10}));</code></pre>
          <h3>Functions</h3>
          <h4>benchmark(fn,opts)</h4>

          <p>benchmark will run fn a number of times specified by opts, either in iterations or elapsed time,
          and return stats about the runtime performance of that fn.</p>

          <h5>Parameters</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>fn</td>
              <td>function</td>
              <td>the function to benchmark</td>
            </tr>
            <tr>
              <td>opts</td>
              <td>object</td>
              <td>the options object which specifies iterations, timeout(ms), or both</td>
            </tr>
          </table>
          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>avg</td>
              <td>float</td>
              <td>average runtime for each call to fn (ms)</td>
            <tr>
            <tr>
              <td>min</td>
              <td>float</td>
              <td>minimum runtime for each call to fn (ms)</td>
            </tr>
            <tr>
              <td>total</td>
              <td>float</td>
              <td>total time it takes to run every iteration of fn (ms)</td>
            </tr>
            <tr>
              <td>iters</td>
              <td>int</td>
              <td>total number of times fn executed</td>
            </tr>
          </table> 
      </div>

      <hr>
      <a name="collide"></a>
      <div class="jump" id="collideRef">  
        <h2>Collide</h2>
          <p>The collision library is used to test collisions between various shapes. The compiled collide.js can be viewed [here](../sald/collide.js)</p>
          <p>The collide.js currently supports 6 collision detection functions as follows:</p>
          <ul>
            <li>Circle vs Circle</li>
            <li>Rectangle vs Rectangle</li>
            <li>Polygon vs Polygon {Convex}</li>
            <li>Ray vs Circle</li>
            <li>Ray vs Rectangle</li>
            <li>Ray vs Convex Polygon</li>
          </ul>

          <h3>Shape Definitions</h3>

          <h4>Circle</h4>
          <p>A circle defined by the center and radius.</p>
<pre><code>{
  x: the x coordinate of the center of the circle
  y: the y coordinate of the center of the circle
  r: the radius of the circle
}</code></pre>

          <h4>Rectangle</h4>
          <p>A rectangle defined by the top left and bottom right points.</p>
<pre><code>{
  min : {
    x: the minimum x coordinate of the rectangle
    y: the minimum y coordinate of the rectangle
  },
  max: {
    x: the maximum x coordinate of the rectangle
    y: the maximum y coordinate of the rectangle
  }
}</code></pre>

          <h4>Polygon</h4>
          <p>A polygon defined by the verticies.</p>
<pre><code>[
  {
    x: the x coordinate of a vertex in the polygon
    y: the y coordinate of a vertex in the polygon
  },
  ...
]</code></pre>

          <h4>Ray</h4>
          <p>Ray defined by the start and end points.</p>
<pre><code>{
  start: {
    x: x coordinate of the start of the ray
    y: y coordinate of the start of the ray
  },
  end: {
    x: x coordinate of the end of the ray
    y: y coordinate of the end of the ray
  }
}</code></pre>

          <h3>Functions</h3>

          <h4>function rectangleRectangle(r1,r2)</h4>
          <p>Check to see if r1 and r2 overlap</p>

          <h5>Parameters</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>r1</td>
              <td>Rectangle</td>
              <td>First rectangle to check</td>
            </tr>
            <tr>
              <td>r2</td>
              <td>Rectangle</td>
              <td>Second rectangle to check</td>
            </tr>
          </table>

          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>var</td>
              <td>bool</td>
              <td>true if r1 and r2 overlap, otherwise false</td>
            </tr>
          </table>

          <h4>function rayRectangle(r,b)</h4>
          <p>Check to see if r intersetcts b, and return where if it does</p>

          <h3>Parameters</h3>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>r</td>
              <td>Ray</td>
              <td>Ray to check for intersection</td>
            </tr>
            <tr>
              <td>b</td>
              <td>Rectangle</td>
              <td>Rectangle being intersected</td>
            </tr>
          </table>

          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>var</td>
              <td>object</td>
              <td>{t: t} if there is an intersection at (r.start + (r.end - r.start)*t), otherwise null</td>
            </tr>
          </table>

          <h4>function circleCircle(c1,c2)</h4>
          <p>Check to see if c1 and c2 overlap</p>

          <h3>Parameters</h3>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>c1</td>
              <td>Circle</td>
              <td>First circle to check</td>
            </tr>
            <tr>
              <td>c2</td>
              <td>Circle</td>
              <td>Second circle to check</td>
            </tr>
          </table>

          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>var</td>
              <td>bool</td>
              <td>true if c1 and c2 overlap, otherwise false</td>
            </tr>
          </table>

          <h4>function rayCircle(r,c)</h4>
          <p>Check to see if r intersetcts c, and return where if it does</p>

          <h5>Parameters</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>r</td>
              <td>Ray</td>
              <td>Ray to check for intersection</td>
            </tr>
            <tr>
              <td>c</td>
              <td>Circle</td>
              <td>Circle to being intersected</td>
            </tr>
          </table>

          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>var</td>
              <td>object</td>
              <td>{t: t} if there is an intersection at (r.start + (r.end - r.start)*t), otherwise null</td>
            </tr>
          </table>

          <h4>function convexConvex(p1, p2)</h4>
          <p>Check to see if p1 and p2 (Convex Polygons) overlap</p>

          <h5>Parameters</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>p1</td>
              <td>Polygon</td>
              <td>First polygon to check</td>
            </tr>
            <tr>
              <td>p2</td>
              <td>Polygon</td>
              <td>Second polygon to check</td>
            </tr>
          </table>

          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>var</td>
              <td>bool</td>
              <td>true if p1 and p2 overlap, otherwise false</td>
            </tr>
          </table>

          <h4>function rayConvex(r,p)</h4>
          <p>Check to see if r intersetcts p (Convex Polygon), and return where if it does</p>

          <h5>Parameters</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Param</td>
              <td>Type</td>
              <td>Decription</td>
            </tr>
            <tr>
              <td>r</td>
              <td>Ray</td>
              <td>Ray to check for intersection</td>
            </tr>
            <tr>
              <td>p</td>
              <td>Polygon</td>
              <td>Polygon being intersected</td>
            </tr>
          </table>

          <h5>Returns</h5>
          <table>
            <tr style="font-weight: bold;">
              <td>Return</td>
              <td>Type</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>var</td>
              <td>object</td>
              <td>{t: t} if there is an intersection at (r.start + (r.end - r.start)*t), otherwise null</td>
            </tr>
          </table>
          <h4><a href="#top">Return to top</a></h4>
      </div>

      <hr>
      <a name="gameobject"></a>
      <div class="jump" id="gameobjectRef">  
        <h2>Game Object</h2>
        <h4><a href="#top">Return to top</a></h4>
      </div>

      <hr>
      <a name="mainloop"></a>
      <div class="jump" id="mainloopRef">  
        <h2>Mainloop</h2>
        <p>SALD provides a basic mainloop. To use, attach to a canvas with:</p>
<pre><code>mainloop.start( ):
var mainloop = require('sald:mainloop.js');

//configure size and callbacks:
sald.size = {x:320, y:240, mode:"exact"};
sald.scene = myScene;

//call this once the page has loaded:
mainloop.start(document.getElementById("canvas"));</code></pre>

        <p>
          The <code>mainloop.start()</code> method takes a second options argument, which currently only has one supported option -- <code>gl</code> -- which creates a webgl context instead of a 2d context, and uses the supplied attributes:
        </p>
        <ul>
          mainloop.start(document.getElementById("canvas"), {gl:{}}); //webgl canvas, default attribs
          mainloop.start(document.getElementById("canvas"), {gl:{antialias:false}}); //webgl canvas, 'antialias' attribs set false
        </ul>

        <p>A list of possible attributes are available at https://www.khronos.org/registry/webgl/specs/1.0/#5.2 .</p>

        <p>The mainloop module uses the following properties in the `sald` namespace:</p>

        <h3>Canvas</h3>

        <p>sald.size configures the desired canvas size and resizing behavior:</p>

        <p>If mode is not specified, or is "exact"` size is set exactly in pixels:</p>
<pre><code>sald.size = {x:320, y:240}; 
sald.size = {x:320, y:240, mode:"exact"};</code></pre>

        <p>If <code>mode</code> is <code>multiple</code>, canvas size will be an integer multiple of the given size.
      This is good for pixel-art games, or games that want an exact aspect ratio:</p>
        <ul>
          sald.size = {x:320, y:240, mode:"multiple"}; //pixel art game with 320x240 canvas
          sald.size = {x:16, y:9, mode:"multiple"}; //game wants to be exactly 16x9 aspect
        </ul>

        <p>If <code>mode</code> is <code>ratio</code>, canvas size will be an rounded, non-integer multiple of the size.
        This is good for games that just want an approximate aspect ratio:</p>
        <ul>
          sald.size = {x:1, y:1, mode:"ratio"}; //square canvas
          sald.size = {x:16, y:9, mode:"ratio"}; //16x9-ish, might not be exact due to rounding
        </ul>
        <hr>

        <p>`sald.ctx` is the drawing context associated with the canvas. SALD adds some extra properties:</p>
        <ul>
          sald.ctx.width //current width
          sald.ctx.height //current height
          sald.ctx.factor //scaling factor relative to sald.size
        </ul>

        <p>One generally uses `ctx.factor` to set the `ctx`'s transform to allow working in "virtual pixels":</p>

<pre><code>sald.size = {x:320, y:240, mode:"multiple"}; //canvas will be some multiple of 320x240
function draw() {
  var ctx = sald.ctx;

  //scale to account for pixel size:
  ctx.setTransform(ctx.factor,0, 0,ctx.factor, 0,0);

  //draw full-screen pink rectangle:
  ctx.fillStyle = "#f0f"; //bright pink
  ctx.fillRect(0, 0, 320, 240); //&lt;-- working in pixel units

}</code></pre>

        <h3>Input</h3>

        <p>`sald.keys` contains the names of every held-down key. (Key names are specified in mainloop.js)</p>

<pre><code>function update(elapsed) {
  var keys = sald.keys;
  if (keys.LEFT) player.x -= 10.0 * elapsed;
  if (keys.RIGHT) player.x += 10.0 * elapsed;
}</code></pre>

        <hr>

        <p>sald.mouse contains the position (in pixels from the upper-left corner of the canvas) and held-down buttons for the mouse. NOTE: `mouse === null` if no mouse events have happened yet.</p>

<pre><code>function update(elapsed) {
  var mouse = sald.mouse;
  if (mouse && mouse.buttons.LEFT) {
    console.log("Left button held down; currently at " + mouse.x + ", " + mouse.y + ".");
  }
}</code></pre>

        <h3>Callbacks</h3>

        <p>The `sald.scene` object holds callbacks used by the mainloop to define custom update, draw, and event handlers. You can package handlers together and assign to scene all at once, or assign each function individually.</p>

        <p>The `sald.scene.update` function is called with the current elapsed time. You can use it to update game state.</p>

        <p>The `sald.scene.draw` function is called once per frame. It should draw the current game state into `sald.ctx`.</p>

        <p>Considering the Model-View-Controller paradigm, the update function should update the model, while the draw function should update the view.</p>

<pre><code>function update(elapsed){
  // elapsed is a float measure of how many seconds have passed since the last update
}

sald.scene.update = update;

function draw(){
  // draw whatever should be on the screen, using sald.ctx
}

sald.scene.draw = draw;</code></pre>

        <hr>

        <p>The `sald.scene.key` function is called every time a key is pressed or released:</p>

<pre><code>function key(keyName, isPressed){
  if (keyName === "SPACE" && isPressed) {
    console.log("You pressed space.");
  }
}

window.sald.scene.key = key;</code></pre>

        <p>NOTE: On a Mac, `sald.keys.WINDOWS` is the "Command" key.</p>

        <hr>

        <p>The `sald.scene.mouse` function is called whenever a mouse button is pressed or the mouse moves:</p>

<pre><code>function mouse(position, buttonName, isPressed) {
  if (buttonName === undefined) {
    //just movement
  } else {
    if (buttonName === "MIDDLE") {
      console.log("Middle button " + (isPressed ? "down" : "up") + ".");
    }
  }
}
sald.scene.mouse = mouse;</code></pre>

        <p>NOTE: when the mouse is moved, this function will be called with `buttonName` and `isPressed` undefined.</p>

NOTE 2: `sald.takeRightClickInput` (default: true) can be set to false to allow right click events to open the context menu as expected.

        <hr>

        <p>The `sald.scene.wheel` function handles scroll wheel events:</p>
<pre><code>function wheel(delta) {
}
sald.scene.wheel = wheel;</code></pre>

        <p>NOTE: if not defined, scroll events will scroll the page as usual.</p>
        <h4><a href="#top">Return to top</a></h4>
      </div>

      <hr>
      <a name="sound"></a>
      <div class="jump" id="soundRef">  
        <h2>Sound</h2>
        <h4><a href="#top">Return to top</a></h4>
      </div>

      <hr>
      <a name="sprite"></a>
      <div class="jump" id="spriteRef">  
        <h2>Sprite</h2>
        <h4><a href="#top">Return to top</a></h4>
      </div>

      <hr>
      <div class="jump" id="tilemapRef">  
        <a name="tilemap"></a>
        <h2>Tilemap</h2>
        <h4><a href="#top">Return to top</a></h4>
      </div>
    </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->  
  </body>
</html>
